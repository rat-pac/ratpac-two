doc/users_guide/overview.rst:to define and experiment and run the simulation with the stand-alone executable---:bash:`rat`---along with any user defined
install/share/RAT/doc/users_guide/overview.rst:to define and experiment and run the simulation with the stand-alone executable---:bash:`rat`---along with any user defined
src/db/src/DB.cc:  DBTableKey id(table->GetName(), table->GetIndex());
src/db/src/DB.cc:  if (table->IsDefault()) {
src/db/src/DB.cc:  } else if (table->IsUser()) {
src/db/src/DB.cc:    for (int i = table->GetRunBegin(); i <= table->GetRunEnd(); i++) {
src/db/src/DB.cc:  table->SetUser();
src/db/src/DBTextLoader.cc:      if (table->GetFieldType("name") == DBTable::STRING)
src/db/src/DBTextLoader.cc:        table->SetName(table->GetS("name"));
src/db/src/DBTextLoader.cc:      if (table->GetFieldType("index") == DBTable::STRING) table->SetIndex(table->GetS("index"));
src/db/src/DBTextLoader.cc:      if (table->GetFieldType("run_range") == DBTable::INTEGER_ARRAY && table->GetIArray("run_range").size() == 2) {
src/db/src/DBTextLoader.cc:        const std::vector<int> &run_range = table->GetIArray("run_range");
src/db/src/DBTextLoader.cc:        table->SetRunRange(run_range[0], run_range[1]);
src/db/src/DBTextLoader.cc:      } else if (table->GetFieldType("valid_begin") == DBTable::INTEGER_ARRAY &&
src/db/src/DBTextLoader.cc:                 table->GetIArray("valid_begin").size() == 2 &&
src/db/src/DBTextLoader.cc:                 table->GetFieldType("valid_end") == DBTable::INTEGER_ARRAY &&
src/db/src/DBTextLoader.cc:                 table->GetIArray("valid_end").size() == 2) {
src/db/src/DBTextLoader.cc:        const std::vector<int> &valid_begin = table->GetIArray("valid_begin");
src/db/src/DBTextLoader.cc:        const std::vector<int> &valid_end = table->GetIArray("valid_end");
src/db/src/DBTextLoader.cc:          table->Set("run_range", run_range);
src/db/src/DBTextLoader.cc:          table->SetRunRange(run_range[0], run_range[1]);
src/db/src/DBTextLoader.cc:          table->Set("run_range", run_range);
src/db/src/DBTextLoader.cc:          table->SetRunRange(run_range[0], run_range[1]);
src/db/src/DBTextLoader.cc:        warn << "Table " << table->GetName() << " has bad/missing validity information." << newline << "Discarding..."
src/io/src/OutNtupleProc.cc:    defaultFilename = table->GetS("default_output_filename");
src/io/src/OutNtupleProc.cc:    options.tracking = table->GetZ("include_tracking");
src/io/src/OutNtupleProc.cc:    options.mcparticles = table->GetZ("include_mcparticles");
src/io/src/OutNtupleProc.cc:    options.pmthits = table->GetZ("include_pmthits");
src/io/src/OutNtupleProc.cc:    options.untriggered = table->GetZ("include_untriggered_events");
src/io/src/OutNtupleProc.cc:    options.mchits = table->GetZ("include_mchits");
src/gen/src/PosGen_TriMeshSurface.cc:  const std::vector<double> &x = ltable->GetDArray("x");
src/gen/src/PosGen_TriMeshSurface.cc:  const std::vector<double> &y = ltable->GetDArray("y");
src/gen/src/PosGen_TriMeshSurface.cc:  const std::vector<double> &z = ltable->GetDArray("z");
src/gen/src/PosGen_Multipoint.cc:  const std::vector<double> &x = ltable->GetDArray("x");
src/gen/src/PosGen_Multipoint.cc:  const std::vector<double> &y = ltable->GetDArray("y");
src/gen/src/PosGen_Multipoint.cc:  const std::vector<double> &z = ltable->GetDArray("z");
src/geo/src/GeoPerfBoxFactory.cc:  std::string volumeName = table->GetIndex();
src/geo/src/GeoPerfBoxFactory.cc:  std::vector<double> size = table->GetDArray("size");
src/geo/src/GeoPerfBoxFactory.cc:    thickness = table->GetD("thickness") * CLHEP::mm;
src/geo/src/GeoPerfBoxFactory.cc:  std::vector<double> rhole = table->GetDArray("r_hole");
src/geo/src/GeoPerfBoxFactory.cc:  std::vector<double> xhole = table->GetDArray("x_hole");
src/geo/src/GeoPerfBoxFactory.cc:  std::vector<double> yhole = table->GetDArray("y_hole");
src/geo/src/GeoPolyArrayFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoPolyArrayFactory.cc:  G4double size_z = table->GetD("size_z") * CLHEP::mm;  // half thickness of plate
src/geo/src/GeoPolyArrayFactory.cc:  std::string poly_table_name = table->GetS("poly_table");
src/geo/src/GeoPolyArrayFactory.cc:  const std::vector<G4double> &vertex_pnts_x = lpoly_table->GetDArray("x");
src/geo/src/GeoPolyArrayFactory.cc:  const std::vector<G4double> &vertex_pnts_y = lpoly_table->GetDArray("y");
src/geo/src/GeoPolyArrayFactory.cc:    scale_fac = table->GetD("scale_fac");
src/geo/src/GeoPolyArrayFactory.cc:    scale_fac_in = table->GetD("scale_fac_in");
src/geo/src/GeoEosFactory.cc:  G4double r_min = table->GetD("r_min");
src/geo/src/GeoEosFactory.cc:  G4double r_max = table->GetD("r_max");
src/geo/src/GeoEosFactory.cc:  G4double size_z = table->GetD("size_z");
src/geo/src/GeoEosFactory.cc:  G4double top_radius = table->GetD("top_radius");
src/geo/src/GeoEosFactory.cc:  G4double top_height = table->GetD("top_height");
src/geo/src/GeoTorusFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoTorusFactory.cc:  G4double r_max = table->GetD("r_max") * CLHEP::mm;
src/geo/src/GeoTorusFactory.cc:  G4double r_torus = table->GetD("r_torus") * CLHEP::mm;
src/geo/src/GeoTorusFactory.cc:    r_min = table->GetD("r_min") * CLHEP::mm;
src/geo/src/GeoTorusFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoTorusFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoConvexLensFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoConvexLensFactory.cc:  G4double R1 = table->GetD("R1") * CLHEP::mm;
src/geo/src/GeoConvexLensFactory.cc:  G4double thickness = table->GetD("thickness") * CLHEP::mm;
src/geo/src/GeoConvexLensFactory.cc:    R2 = table->GetD("R2") * CLHEP::mm;
src/geo/src/GeoConvexLensFactory.cc:    diameter = table->GetD("diameter") * CLHEP::mm;
src/geo/src/GeoRevolutionChimneyFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoRevolutionChimneyFactory.cc:  const std::vector<double> &z = table->GetDArray("z");
src/geo/src/GeoRevolutionChimneyFactory.cc:  const std::vector<double> &r_max = table->GetDArray("r_max");
src/geo/src/GeoRevolutionChimneyFactory.cc:  const std::vector<double> &r_min = table->GetDArray("r_min");
src/geo/src/GeoRevolutionChimneyFactory.cc:  const double rout_chim = table->GetD("rout_chimney");
src/geo/src/GeoRevolutionChimneyFactory.cc:    rin_chim = table->GetD("rin_chimney");
src/geo/src/GeoRevolutionChimneyFactory.cc:  const double z_bot = table->GetD("bottom_chimney");
src/geo/src/GeoRevolutionChimneyFactory.cc:  const double z_top = table->GetD("top_chimney");
src/geo/src/GeoRevolutionChimneyFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoRevolutionChimneyFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/WLSPFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/WLSPFactory.cc:  const std::vector<double> &size = table->GetDArray("size");
src/geo/src/WLSPFactory.cc:  const std::vector<double> &z = table->GetDArray("z");
src/geo/src/WLSPFactory.cc:  const std::vector<double> &r_max = table->GetDArray("r_max");
src/geo/src/WLSPFactory.cc:    r_min = table->GetDArray("r_min");
src/geo/src/WLSPFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/WLSPFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoReflectorFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoReflectorFactory.cc:  std::string mother_name = table->GetS("mother");
src/geo/src/GeoReflectorFactory.cc:  G4double r_min = table->GetD("r_min") * CLHEP::mm;
src/geo/src/GeoReflectorFactory.cc:  G4Material *inMaterial = G4Material::GetMaterial(table->GetS("inmaterial"));
src/geo/src/GeoReflectorFactory.cc:  G4Material *outMaterial = G4Material::GetMaterial(table->GetS("outmaterial"));
src/geo/src/GeoReflectorFactory.cc:  std::string surface = table->GetS("reflectivesurface");
src/geo/src/GeoReflectorFactory.cc:  std::string pmt_table = table->GetS("pmt_table");
src/geo/src/GeoTubeIntersectionFactory.cc:  std::string volumeName = table->GetIndex();
src/geo/src/GeoTubeIntersectionFactory.cc:  std::vector<double> posz = table->GetDArray("pos_z");
src/geo/src/GeoTubeIntersectionFactory.cc:  std::vector<double> rmax = table->GetDArray("r_max");
src/geo/src/GeoTubeIntersectionFactory.cc:    rmin = table->GetDArray("r_min");
src/geo/src/GeoTubeIntersectionFactory.cc:    phiStart = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoTubeIntersectionFactory.cc:    phiDelta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoTubeIntersectionFactory.cc:  std::vector<double> poszInter = table->GetDArray("pos_z_inter");
src/geo/src/GeoTubeIntersectionFactory.cc:  std::vector<double> phiInter = table->GetDArray("phi_inter");
src/geo/src/GeoTubeIntersectionFactory.cc:  std::vector<double> sizezInter = table->GetDArray("size_z_inter");
src/geo/src/GeoTubeIntersectionFactory.cc:  std::vector<double> rmaxInter = table->GetDArray("r_max_inter");
src/geo/src/GeoTubeIntersectionFactory.cc:    rminInter = table->GetDArray("r_min_inter");
src/geo/src/GeoTubeIntersectionFactory.cc:    dispInter = table->GetDArray("disp_inter");
src/geo/src/GeoTubeIntersectionFactory.cc:    std::vector<int> includeInter = table->GetIArray("include_inter");
src/geo/src/WaterBoxConstruction.cc:  std::string volume_name = table->GetIndex();
src/geo/src/WaterBoxConstruction.cc:  const std::vector<double> &size = table->GetDArray("boxsize");
src/geo/src/WaterBoxConstruction.cc:  G4double thickness = table->GetD("boxthickness");
src/geo/src/WaterBoxConstruction.cc:  G4double cornervoid = table->GetD("airgapincorner");
src/geo/src/GeoSurfaceFactory.cc:  detail << "GeoSurfaceFactory: Constructing border " << table->GetIndex() << newline;
src/geo/src/GeoSurfaceFactory.cc:  std::string border_name = table->GetIndex();
src/geo/src/GeoSurfaceFactory.cc:    volume1_name = table->GetS("volume1");
src/geo/src/GeoSurfaceFactory.cc:    volume2_name = table->GetS("volume2");
src/geo/src/GeoSurfaceFactory.cc:      std::string surface_name = table->GetS("surface");
src/geo/src/GeoSurfaceFactory.cc:        reverse = table->GetI("reverse");
src/geo/src/GeoRevArrayFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoRevArrayFactory.cc:  const std::vector<double> &z = table->GetDArray("z");
src/geo/src/GeoRevArrayFactory.cc:  const std::vector<double> &r_max = table->GetDArray("r_max");
src/geo/src/GeoRevArrayFactory.cc:  const std::vector<double> &r_min = table->GetDArray("r_min");
src/geo/src/GeoRevArrayFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoRevArrayFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoRevArrayFactory.cc:    s_cut_r = table->GetD("sphere_cut_r") * CLHEP::mm;
src/geo/src/GeoRevArrayFactory.cc:    rescale_r = table->GetD("rescale_radius") * CLHEP::mm;
src/geo/src/GeoRevArrayFactory.cc:    preflip = table->GetI("preflip");
src/geo/src/GeoLensFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoLensFactory.cc:  G4double diameter = table->GetD("diameter") * CLHEP::mm;
src/geo/src/GeoLensFactory.cc:  G4double R1 = table->GetD("R1") * CLHEP::mm;
src/geo/src/GeoLensFactory.cc:  G4double thickness = table->GetD("thickness") * CLHEP::mm;
src/geo/src/GeoLensFactory.cc:    R2 = table->GetD("R2") * CLHEP::mm;
src/geo/src/GeoTubeFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoTubeFactory.cc:  G4double r_max = table->GetD("r_max") * CLHEP::mm;
src/geo/src/GeoTubeFactory.cc:  G4double size_z = table->GetD("size_z") * CLHEP::mm;
src/geo/src/GeoTubeFactory.cc:    r_min = table->GetD("r_min") * CLHEP::mm;
src/geo/src/GeoTubeFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoTubeFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::string volumeName = table->GetIndex();
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::string motherName = table->GetS("mother");
src/geo/src/GeoCherenkovSourceFactory.cc:  G4Material *sourceMaterial = G4Material::GetMaterial(table->GetS("source_material"));
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::vector<double> &sourceColor = table->GetDArray("source_vis_color");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double neckOd = table->GetD("neck_od");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double neckOdLen = table->GetD("neck_od_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double neckId = table->GetD("neck_id");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double neckIdLen = table->GetD("neck_id_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double ballOd = table->GetD("ball_od");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double ballId = table->GetD("ball_id");
src/geo/src/GeoCherenkovSourceFactory.cc:      G4Material::GetMaterial(table->GetS("decay_chamber_material"));  // inside the decay chamber
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::vector<double> &decayChamberColor = table->GetDArray("decay_chamber_vis_color");
src/geo/src/GeoCherenkovSourceFactory.cc:  G4Material *blackPaintMaterial = G4Material::GetMaterial(table->GetS("black_paint_material"));
src/geo/src/GeoCherenkovSourceFactory.cc:  const double blackPaintThickness = table->GetD("black_paint_thickness");
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::vector<double> &blackPaintColor = table->GetDArray("black_paint_vis_color");
src/geo/src/GeoCherenkovSourceFactory.cc:  G4Material *whitePaintMaterial = G4Material::GetMaterial(table->GetS("white_paint_material"));
src/geo/src/GeoCherenkovSourceFactory.cc:  const double whitePaintThickness = table->GetD("white_paint_thickness");
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::vector<double> &whitePaintColor = table->GetDArray("white_paint_vis_color");
src/geo/src/GeoCherenkovSourceFactory.cc:  G4OpticalSurface *paintSurface = GetSurface(table->GetS("paint_surface"));
src/geo/src/GeoCherenkovSourceFactory.cc:  G4Material *sleeveMaterial = G4Material::GetMaterial(table->GetS("sleeve_material"));
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::vector<double> &sleeveColor = table->GetDArray("sleeve_vis_color");
src/geo/src/GeoCherenkovSourceFactory.cc:  G4Material *windowMaterial = G4Material::GetMaterial(table->GetS("window_material"));
src/geo/src/GeoCherenkovSourceFactory.cc:  const double windowThickness = table->GetD("window_thickness");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double windowOd1 = table->GetD("window_od1");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double windowOd1Len = table->GetD("window_od1_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double windowOd2 = table->GetD("window_od2");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double windowOd2Len = table->GetD("window_od2_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::vector<double> &windowColor = table->GetDArray("window_vis_color");
src/geo/src/GeoCherenkovSourceFactory.cc:  G4Material *tubeMaterial = G4Material::GetMaterial(table->GetS("tube_material"));
src/geo/src/GeoCherenkovSourceFactory.cc:  const double tubeId = table->GetD("tube_id");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double tubeOd = table->GetD("tube_od");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double tubeLength = table->GetD("tube_length");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double tubeOffset = table->GetD("tube_offset");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double tubeRot = table->GetD("tube_rot");
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::vector<double> &tubeColor = table->GetDArray("tube_vis_color");
src/geo/src/GeoCherenkovSourceFactory.cc:  G4Material *canMaterial = G4Material::GetMaterial(table->GetS("can_material"));
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canOd1 = table->GetD("can_od1");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canOd1Len = table->GetD("can_od1_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canOd2 = table->GetD("can_od2");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canOd2Len = table->GetD("can_od2_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canOd3 = table->GetD("can_od3");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canOd3Len = table->GetD("can_od3_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canOd4 = table->GetD("can_od4");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canOd4Len = table->GetD("can_od4_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canId1 = table->GetD("can_id1");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canId1Len = table->GetD("can_id1_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canId2 = table->GetD("can_id2");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canId2Len = table->GetD("can_id2_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canId3 = table->GetD("can_id3");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canId3Len = table->GetD("can_id3_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canId4 = table->GetD("can_id4");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double canId4Len = table->GetD("can_id4_len");
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::vector<double> &canColor = table->GetDArray("can_vis_color");
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::string pmtType = table->GetS("pmt_model");
src/geo/src/GeoCherenkovSourceFactory.cc:  const std::vector<double> &pmtColor = table->GetDArray("pmt_vis_color");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double pmtRadius = table->GetD("pmt_radius");
src/geo/src/GeoCherenkovSourceFactory.cc:  const double pmtHeight = table->GetD("pmt_height");
src/geo/src/GeoCherenkovSourceFactory.cc:  const int pmtLcn = table->GetI("pmt_lcn");
src/geo/src/GeoCherenkovSourceFactory.cc:  G4VPhysicalVolume *motherPhys = FindPhysMother(table->GetS("mother"));
src/geo/src/GeoCherenkovSourceFactory.cc:  G4LogicalVolume *motherLog = FindMother(table->GetS("mother"));
src/geo/src/GeoRevolutionFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoRevolutionFactory.cc:  const std::vector<double> &z = table->GetDArray("z");
src/geo/src/GeoRevolutionFactory.cc:  const std::vector<double> &r_max = table->GetDArray("r_max");
src/geo/src/GeoRevolutionFactory.cc:    r_min = table->GetDArray("r_min");
src/geo/src/GeoRevolutionFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoRevolutionFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoPolygonFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoPolygonFactory.cc:  G4double size_z = table->GetD("size_z") * CLHEP::mm;  // half thickness of plate
src/geo/src/GeoPolygonFactory.cc:  std::string poly_table_name = table->GetS("poly_table");
src/geo/src/GeoPolygonFactory.cc:  const std::vector<G4double> &vertex_pnts_x = lpoly_table->GetDArray("x");
src/geo/src/GeoPolygonFactory.cc:  const std::vector<G4double> &vertex_pnts_y = lpoly_table->GetDArray("y");
src/geo/src/GeoPolygonFactory.cc:    scale_fac = table->GetD("scale_fac");
src/geo/src/GeoPolygonFactory.cc:    scale_fac_in = table->GetD("scale_fac_in");
src/geo/src/GeoPerfTubeFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoPerfTubeFactory.cc:  std::string mother_name = table->GetS("mother");
src/geo/src/GeoPerfTubeFactory.cc:  G4double r_max = table->GetD("r_max") * CLHEP::mm;    // radius of main plate
src/geo/src/GeoPerfTubeFactory.cc:  G4double size_z = table->GetD("size_z") * CLHEP::mm;  // half thickness of plate
src/geo/src/GeoPerfTubeFactory.cc:  G4double r_hole = table->GetD("r_hole") * CLHEP::mm;  // radius of the holes.  If this is std::set <= zero,
src/geo/src/GeoPerfTubeFactory.cc:    r_min = table->GetD("r_min") * CLHEP::mm;
src/geo/src/GeoPerfTubeFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoPerfTubeFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoPerfTubeFactory.cc:    std::string pos_table_name = table->GetS("pos_table");
src/geo/src/GeoPerfTubeFactory.cc:    const std::vector<double> &hole_r = lpos_table->GetDArray("r");  // radial position of hole (mm)
src/geo/src/GeoPerfTubeFactory.cc:    const std::vector<double> &hole_a = lpos_table->GetDArray("a");  // angle of the hole (in radians)
src/geo/src/GeoPerfTubeFactory.cc:    std::string pmt_table = table->GetS("pmt_table");
src/geo/src/GeoPerfTubeFactory.cc:    const std::vector<double> &posvector = table->GetDArray("position");
src/geo/src/GeoReflectorWaveguideFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoReflectorWaveguideFactory.cc:  std::string mother_name = table->GetS("mother");
src/geo/src/GeoReflectorWaveguideFactory.cc:  G4double r_min = table->GetD("r_min") * CLHEP::mm;
src/geo/src/GeoReflectorWaveguideFactory.cc:  G4Material *inMaterial = G4Material::GetMaterial(table->GetS("inmaterial"));
src/geo/src/GeoReflectorWaveguideFactory.cc:  G4Material *outMaterial = G4Material::GetMaterial(table->GetS("outmaterial"));
src/geo/src/GeoReflectorWaveguideFactory.cc:  std::string surface = table->GetS("reflectivesurface");
src/geo/src/GeoReflectorWaveguideFactory.cc:  std::string pmt_table = table->GetS("pmt_table");
src/geo/src/GeoBoxFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoBoxFactory.cc:  const std::vector<double> &size = table->GetDArray("size");
src/geo/src/gdml/GDMLWriteSolids.cc:  auto pvec = ptable->GetProperties();
src/geo/src/gdml/GDMLWriteSolids.cc:  auto cvec = ptable->GetConstProperties();
src/geo/src/gdml/GDMLWriteSolids.cc:      propElement->setAttributeNode(NewAttribute("name", ptable->GetMaterialPropertyNames()[i]));
src/geo/src/gdml/GDMLWriteSolids.cc:      propElement->setAttributeNode(NewAttribute("ref", GenerateName(ptable->GetMaterialPropertyNames()[i], pvec[i])));
src/geo/src/gdml/GDMLWriteSolids.cc:      PropertyVectorWrite(ptable->GetMaterialPropertyNames()[i], pvec[i]);
src/geo/src/gdml/GDMLWriteSolids.cc:      propElement->setAttributeNode(NewAttribute("name", ptable->GetMaterialConstPropertyNames()[i]));
src/geo/src/gdml/GDMLWriteSolids.cc:      propElement->setAttributeNode(NewAttribute("ref", ptable->GetMaterialConstPropertyNames()[i]));
src/geo/src/gdml/GDMLWriteSolids.cc:      constElement->setAttributeNode(NewAttribute("name", ptable->GetMaterialConstPropertyNames()[i]));
src/geo/src/gdml/GDMLWriteStructure.cc:    for (auto pos = stable->cbegin(); pos != stable->cend(); ++pos) {
src/geo/src/gdml/GDMLWriteStructure.cc:    for (auto pos = btable->cbegin(); pos != btable->cend(); ++pos) {
src/geo/src/GeoWaterBoxArrayFactory.cc:  info << "GeoWaterBoxArrayFactory: Constructing volume " + table->GetIndex() << newline;
src/geo/src/GeoWaterBoxArrayFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoWaterBoxArrayFactory.cc:  std::string mother_name = table->GetS("mother");
src/geo/src/GeoWaterBoxArrayFactory.cc:  std::string pos_table_name = table->GetS("waterbox_locations");
src/geo/src/GeoWaterBoxArrayFactory.cc:  const std::vector<double> &box_x = lpos_table->GetDArray("x");
src/geo/src/GeoWaterBoxArrayFactory.cc:  const std::vector<double> &box_y = lpos_table->GetDArray("y");
src/geo/src/GeoWaterBoxArrayFactory.cc:  const std::vector<double> &box_z = lpos_table->GetDArray("z");
src/geo/src/GeoSphereFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoSphereFactory.cc:  G4double r_max = table->GetD("r_max") * CLHEP::mm;
src/geo/src/GeoSphereFactory.cc:    r_min = table->GetD("r_min") * CLHEP::mm;
src/geo/src/GeoSphereFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoSphereFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoSphereFactory.cc:    theta_start = table->GetD("theta_start") * CLHEP::deg;
src/geo/src/GeoSphereFactory.cc:    theta_delta = table->GetD("theta_delta") * CLHEP::deg;
src/geo/src/GeoCalibrationStickFactory.cc:  const std::string volumeName = table->GetIndex();
src/geo/src/GeoCalibrationStickFactory.cc:  const std::string motherName = table->GetS("mother");
src/geo/src/GeoCalibrationStickFactory.cc:  const double innerDiameter = table->GetD("inner_diameter");
src/geo/src/GeoCalibrationStickFactory.cc:  const double outerDiameter = table->GetD("outer_diameter");
src/geo/src/GeoCalibrationStickFactory.cc:  const double bottomThickness = table->GetD("bottom_thickness");
src/geo/src/GeoCalibrationStickFactory.cc:  const double sourceThickness = table->GetD("source_thickness");
src/geo/src/GeoCalibrationStickFactory.cc:  const double stickLength = table->GetD("stick_length");
src/geo/src/GeoCalibrationStickFactory.cc:  const double sourcePosition = table->GetD("source_position");
src/geo/src/GeoCalibrationStickFactory.cc:  const std::vector<double> positionArray = table->GetDArray("position");
src/geo/src/GeoCalibrationStickFactory.cc:  G4Material *stickMaterial = G4Material::GetMaterial(table->GetS("stick_material"));
src/geo/src/GeoCalibrationStickFactory.cc:  // const std::vector<double> &sourceColor = table->GetDArray("source_vis_color");
src/geo/src/GeoCalibrationStickFactory.cc:  G4Material *bottomMaterial = G4Material::GetMaterial(table->GetS("bottom_material"));
src/geo/src/GeoCalibrationStickFactory.cc:  G4Material *sourceMaterial = G4Material::GetMaterial(table->GetS("source_material"));
src/geo/src/GeoCalibrationStickFactory.cc:  G4Material *gasMaterial = G4Material::GetMaterial(table->GetS("gas_material"));
src/geo/src/GeoCalibrationStickFactory.cc:  // G4OpticalSurface *paintSurface = GetSurface(table->GetS("paint_surface"));
src/geo/src/GeoCalibrationStickFactory.cc:  SetVis(stickLog, table->GetDArray("stick_color"));
src/geo/src/GeoCalibrationStickFactory.cc:  SetVis(bottomLog, table->GetDArray("bottom_color"));
src/geo/src/GeoCalibrationStickFactory.cc:  SetVis(sourceLog, table->GetDArray("source_color"));
src/geo/src/GeoPerfSphereFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoPerfSphereFactory.cc:  G4double r_max = table->GetD("r_max") * CLHEP::mm;
src/geo/src/GeoPerfSphereFactory.cc:    r_min = table->GetD("r_min") * CLHEP::mm;
src/geo/src/GeoPerfSphereFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoPerfSphereFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoPerfSphereFactory.cc:    theta_start = table->GetD("theta_start") * CLHEP::deg;
src/geo/src/GeoPerfSphereFactory.cc:    theta_delta = table->GetD("theta_delta") * CLHEP::deg;
src/geo/src/GeoPerfSphereFactory.cc:  std::string pos_table_name = table->GetS("pos_table");
src/geo/src/GeoPerfSphereFactory.cc:  const std::vector<double> &pos_x = lpos_table->GetDArray("x");
src/geo/src/GeoPerfSphereFactory.cc:  const std::vector<double> &pos_y = lpos_table->GetDArray("y");
src/geo/src/GeoPerfSphereFactory.cc:  const std::vector<double> &pos_z = lpos_table->GetDArray("z");
src/geo/src/GeoPerfSphereFactory.cc:  const std::vector<double> &r_hole_array = lpos_table->GetDArray("r_hole");
src/geo/src/GeoFactory.cc:    std::string sensitive_detector = table->GetS("sensitive_detector");
src/geo/src/GeoFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoFactory.cc:    const std::vector<double> &orientvector = table->GetDArray("orientation");
src/geo/src/GeoFactory.cc:    const std::vector<double> &rotvector = table->GetDArray("rotation");
src/geo/src/GeoFactory.cc:    const std::vector<double> &posvector = table->GetDArray("position");
src/geo/src/GeoFactory.cc:    position.setX(table->GetD("posx") * CLHEP::mm);
src/geo/src/GeoFactory.cc:    position.setY(table->GetD("posy") * CLHEP::mm);
src/geo/src/GeoFactory.cc:    position.setZ(table->GetD("posz") * CLHEP::mm);
src/geo/src/GeoFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoFactory.cc:  int replicas = table->GetI("replicas");
src/geo/src/GeoFactory.cc:  std::string axis_str = table->GetS("replica_axis");
src/geo/src/GeoFactory.cc:  G4double replica_spacing = table->GetD("replica_spacing") * CLHEP::mm;
src/geo/src/GeoBuilder.cc:      std::string name = i_table->first;
src/geo/src/GeoBuilder.cc:      DBLinkPtr table = i_table->second;
src/geo/src/GeoBuilder.cc:        mother = table->GetS("mother");
src/geo/src/GeoBuilder.cc:        type = table->GetS("type");
src/geo/src/GeoBuilder.cc:        enabled = table->GetI("enable");
src/geo/src/GeoBuilder.cc:          volume1 = table->GetS("volume1");
src/geo/src/GeoBuilder.cc:          volume2 = table->GetS("volume2");
src/geo/src/GeoBuilder.cc:        std::string name = i_table->first;
src/geo/src/GeoBuilder.cc:        DBLinkPtr table = i_table->second;
src/geo/src/GeoBuilder.cc:        err += "  " + name + " depends on " + table->GetS("mother") + "\n";
src/geo/src/GeoBubbleFactory.cc:  std::string name = table->GetIndex();
src/geo/src/GeoBubbleFactory.cc:  std::string mother_name = table->GetS("mother");
src/geo/src/GeoBubbleFactory.cc:    Log::Die("Unable to find mother volume \"" + mother_name + "\" for " + table->GetName() + "[" + table->GetIndex() +
src/geo/src/GeoBubbleFactory.cc:  G4Material *material = G4Material::GetMaterial(table->GetS("material"));
src/geo/src/GeoBubbleFactory.cc:  int count = table->GetI("count");
src/geo/src/GeoBubbleFactory.cc:  double radius_mean = table->GetD("radius_mean");
src/geo/src/GeoBubbleFactory.cc:  double radius_sigma = table->GetD("radius_sigma");
src/geo/src/pmt/LAPPDConstruction.cc:  fParams.width = table->GetD("width");
src/geo/src/pmt/LAPPDConstruction.cc:  fParams.thick = table->GetD("thick");
src/geo/src/pmt/LAPPDConstruction.cc:  fParams.glassThickness = table->GetD("glass_thickness");
src/geo/src/pmt/LAPPDConstruction.cc:  fParams.glass = G4Material::GetMaterial(table->GetS("glass_material"));
src/geo/src/pmt/LAPPDConstruction.cc:  fParams.vacuum = G4Material::GetMaterial(table->GetS("pmt_vacuum_material"));
src/geo/src/pmt/LAPPDConstruction.cc:  std::string pc_surface_name = table->GetS("photocathode_surface");
src/geo/src/pmt/LAPPDConstruction.cc:    double efficiency_correction = table->GetD("efficiency_correction");
src/geo/src/pmt/LAPPDConstruction.cc:  std::string pmt_model = table->GetS("index");
src/geo/src/pmt/ToroidalPMTConstruction.cc:  fParams.zEdge = table->GetDArray("z_edge");
src/geo/src/pmt/ToroidalPMTConstruction.cc:  fParams.rhoEdge = table->GetDArray("rho_edge");
src/geo/src/pmt/ToroidalPMTConstruction.cc:  fParams.zOrigin = table->GetDArray("z_origin");
src/geo/src/pmt/ToroidalPMTConstruction.cc:  fParams.dynodeRadius = table->GetD("dynode_radius");
src/geo/src/pmt/ToroidalPMTConstruction.cc:  fParams.dynodeTop = table->GetD("dynode_top");
src/geo/src/pmt/ToroidalPMTConstruction.cc:  fParams.wallThickness = table->GetD("wall_thickness");
src/geo/src/pmt/ToroidalPMTConstruction.cc:    fParams.photocathode_MINrho = table->GetD("photocathode_MINrho");
src/geo/src/pmt/ToroidalPMTConstruction.cc:    fParams.photocathode_MAXrho = table->GetD("photocathode_MAXrho");
src/geo/src/pmt/ToroidalPMTConstruction.cc:  fParams.glass = G4Material::GetMaterial(table->GetS("glass_material"));
src/geo/src/pmt/ToroidalPMTConstruction.cc:  fParams.dynode = G4Material::GetMaterial(table->GetS("dynode_material"));
src/geo/src/pmt/ToroidalPMTConstruction.cc:  fParams.vacuum = G4Material::GetMaterial(table->GetS("pmt_vacuum_material"));
src/geo/src/pmt/ToroidalPMTConstruction.cc:  std::string pc_surface_name = table->GetS("photocathode_surface");
src/geo/src/pmt/ToroidalPMTConstruction.cc:  std::string mirror_surface_name = table->GetS("mirror_surface");
src/geo/src/pmt/ToroidalPMTConstruction.cc:  fParams.dynode_surface = Materials::optical_surface[table->GetS("dynode_surface")];
src/geo/src/pmt/ToroidalPMTConstruction.cc:    double efficiency_correction = table->GetD("efficiency_correction");
src/geo/src/pmt/ToroidalPMTConstruction.cc:    std::string waveguide = table->GetS("waveguide");
src/geo/src/pmt/ToroidalPMTConstruction.cc:    std::string waveguide_desc = table->GetS("waveguide_desc");
src/geo/src/pmt/CubicPMTConstruction.cc:  fParams.pmtWidth = table->GetD("pmt_width");
src/geo/src/pmt/CubicPMTConstruction.cc:  fParams.photocathodeWidth = table->GetD("photocathode_width");
src/geo/src/pmt/CubicPMTConstruction.cc:  fParams.caseThickness = table->GetD("case_thickness");
src/geo/src/pmt/CubicPMTConstruction.cc:  fParams.glassThickness = table->GetD("glass_thickness");
src/geo/src/pmt/CubicPMTConstruction.cc:  fParams.outerCase = G4Material::GetMaterial(table->GetS("case_material"));
src/geo/src/pmt/CubicPMTConstruction.cc:  fParams.glass = G4Material::GetMaterial(table->GetS("glass_material"));
src/geo/src/pmt/CubicPMTConstruction.cc:  fParams.vacuum = G4Material::GetMaterial(table->GetS("pmt_vacuum_material"));
src/geo/src/pmt/CubicPMTConstruction.cc:  std::string pc_surface_name = table->GetS("photocathode_surface");
src/geo/src/pmt/CubicPMTConstruction.cc:  fParams.mirror = Materials::optical_surface[table->GetS("mirror_surface")];
src/geo/src/pmt/CubicPMTConstruction.cc:    double efficiency_correction = table->GetD("efficiency_correction");
src/geo/src/pmt/CubicPMTConstruction.cc:  std::string pmt_model = table->GetS("index");
src/geo/src/pmt/PMTInfoParser.cc:    const vector<double> &pos_x = lpos_table->GetDArray("x");
src/geo/src/pmt/PMTInfoParser.cc:    const vector<double> &pos_y = lpos_table->GetDArray("y");
src/geo/src/pmt/PMTInfoParser.cc:    const vector<double> &pos_z = lpos_table->GetDArray("z");
src/geo/src/pmt/PMTInfoParser.cc:    const vector<double> &dir_x = lpos_table->GetDArray("dir_x");
src/geo/src/pmt/PMTInfoParser.cc:    const vector<double> &dir_y = lpos_table->GetDArray("dir_y");
src/geo/src/pmt/PMTInfoParser.cc:    const vector<double> &dir_z = lpos_table->GetDArray("dir_z");
src/geo/src/pmt/PMTInfoParser.cc:    fChannelNumber = lpos_table->GetIArray("channel_number");
src/geo/src/pmt/PMTInfoParser.cc:    fType = lpos_table->GetIArray("type");  // functional type (e.g. inner, veto, etc. - arbitrary integers)
src/geo/src/pmt/PMTInfoParser.cc:    fEfficiencyCorrection = lpos_table->GetDArray("efficiency_corr");  // individual PMT efficiency corrections
src/geo/src/pmt/PMTInfoParser.cc:    fNoiseRate = lpos_table->GetDArray("noise_rate");  // noise rate for individual pmts
src/geo/src/pmt/PMTInfoParser.cc:        lpos_table->GetDArray("afterpulse_fraction");  // fraction of hits with afterpulse for individual pmts
src/geo/src/pmt/PMTInfoParser.cc:    fPMTIDs = lpos_table->GetSArray("pmt_ids");  // Get the PMT IDs from the database
src/geo/src/pmt/PMTInfoParser.cc:    parent_name = parent_table->GetS("mother");
src/geo/src/pmt/RevolutionPMTConstruction.cc:  std::string pmt_model = table->GetS("index");
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.rEdge = table->GetDArray("rho_edge");
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.zEdge = table->GetDArray("z_edge");
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.rInner = table->GetDArray("rho_inner");
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.zInner = table->GetDArray("z_inner");
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.dynodeRadius = table->GetD("dynode_radius");
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.dynodeTop = table->GetD("dynode_top");
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.dynodeHeight = table->GetD("dynode_height");
src/geo/src/pmt/RevolutionPMTConstruction.cc:    fParams.photocathode_MINrho = table->GetD("photocathode_MINrho");
src/geo/src/pmt/RevolutionPMTConstruction.cc:    fParams.photocathode_MAXrho = table->GetD("photocathode_MAXrho");
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.glass = G4Material::GetMaterial(table->GetS("glass_material"));
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.dynode = G4Material::GetMaterial(table->GetS("dynode_material"));
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.vacuum = G4Material::GetMaterial(table->GetS("pmt_vacuum_material"));
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.photocathode = Materials::optical_surface[table->GetS("photocathode_surface")];
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.mirror = Materials::optical_surface[table->GetS("mirror_surface")];
src/geo/src/pmt/RevolutionPMTConstruction.cc:  fParams.dynode_surface = Materials::optical_surface[table->GetS("dynode_surface")];
src/geo/src/pmt/RevolutionPMTConstruction.cc:    double efficiency_correction = table->GetD("efficiency_correction");
src/geo/src/pmt/PMTArrayFactory.cc:  std::string volume_name = table->GetS("index");
src/geo/src/pmt/PMTArrayFactory.cc:  std::string mother_name = table->GetS("mother");
src/geo/src/pmt/PMTArrayFactory.cc:  std::string pos_table_name = table->GetS("pos_table");
src/geo/src/pmt/PMTArrayFactory.cc:    start_idx = table->GetI("start_idx");  // position in this array to start building pmts
src/geo/src/pmt/PMTArrayFactory.cc:    end_idx = table->GetI("end_idx");  // id of the last pmt to build in this array
src/geo/src/pmt/PMTArrayFactory.cc:    flip = table->GetI("flip") != 0;
src/geo/src/pmt/PMTArrayFactory.cc:    new_radius = table->GetD("rescale_radius");
src/geo/src/pmt/PMTArrayFactory.cc:    std::string orient_str = table->GetS("orientation");
src/geo/src/pmt/PMTArrayFactory.cc:    const std::vector<double> &orient_point_array = table->GetDArray("orient_point");
src/geo/src/pmt/PMTConstruction.cc:  std::string construction = table->Get<std::string>("construction");
src/geo/src/pmt/PMTFactoryBase.cc:    std::string volume_name = table->GetS("index");
src/geo/src/pmt/PMTFactoryBase.cc:    std::string mother_name = table->GetS("mother");
src/geo/src/pmt/PMTFactoryBase.cc:    std::string pmt_ids_str = table->GetS("pmt_ids");
src/geo/src/pmt/PMTCoverageFactory.cc:    coverage = table->GetD("coverage");
src/geo/src/pmt/PMTCoverageFactory.cc:    pmtRadius = table->GetD("rescale_radius");
src/geo/src/pmt/PMTCoverageFactory.cc:    pmtDiameter = table->GetD("pmtdiameter");
src/geo/src/GeoSolidArrayFactoryBase.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoSolidArrayFactoryBase.cc:  G4Material *solid_material = G4Material::GetMaterial(table->GetS("material"));
src/geo/src/GeoSolidArrayFactoryBase.cc:    std::string surface_name = table->GetS("surface");
src/geo/src/GeoSolidArrayFactoryBase.cc:    const std::vector<double> &color = table->GetDArray("color");
src/geo/src/GeoSolidArrayFactoryBase.cc:      warn << "GeoSolidFactory error: " << table->GetName() << "[" << table->GetIndex()
src/geo/src/GeoSolidArrayFactoryBase.cc:    std::string drawstyle = table->GetS("drawstyle");
src/geo/src/GeoSolidArrayFactoryBase.cc:      warn << "GeoSolidFactory error: " << table->GetName() << "[" << table->GetIndex()
src/geo/src/GeoSolidArrayFactoryBase.cc:    int invisible = table->GetI("invisible");
src/geo/src/GeoSolidArrayFactoryBase.cc:    std::string sensitive_detector_name = table->GetS("sensitive_detector");
src/geo/src/GeoSolidArrayFactoryBase.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoSolidArrayFactoryBase.cc:  std::string pos_table_name = table->GetS("pos_table");
src/geo/src/GeoSolidArrayFactoryBase.cc:  const std::vector<double> &pos_x = lpos_table->GetDArray("x");
src/geo/src/GeoSolidArrayFactoryBase.cc:  const std::vector<double> &pos_y = lpos_table->GetDArray("y");
src/geo/src/GeoSolidArrayFactoryBase.cc:  const std::vector<double> &pos_z = lpos_table->GetDArray("z");
src/geo/src/GeoSolidArrayFactoryBase.cc:    max_solids = table->GetI("max_num");
src/geo/src/GeoSolidArrayFactoryBase.cc:    start_solid_num = table->GetI("start_num");
src/geo/src/GeoSolidArrayFactoryBase.cc:    sub_type = table->GetI("sub_type");
src/geo/src/GeoSolidArrayFactoryBase.cc:    sub_type_array = lpos_table->GetIArray("sub_type");
src/geo/src/GeoSolidArrayFactoryBase.cc:  std::string mother_name = table->GetS("mother");
src/geo/src/GeoSolidArrayFactoryBase.cc:    std::string rotate_str = table->GetS("rotate_solids");
src/geo/src/GeoSolidArrayFactoryBase.cc:    rot_x = lpos_table->GetDArray("rot_x");
src/geo/src/GeoSolidArrayFactoryBase.cc:    rot_y = lpos_table->GetDArray("rot_y");
src/geo/src/GeoSolidArrayFactoryBase.cc:    rot_z = lpos_table->GetDArray("rot_z");
src/geo/src/GeoSolidArrayFactoryBase.cc:    std::string orient_str = table->GetS("orientation");
src/geo/src/GeoSolidArrayFactoryBase.cc:    dir_x = lpos_table->GetDArray("dir_x");
src/geo/src/GeoSolidArrayFactoryBase.cc:    dir_y = lpos_table->GetDArray("dir_y");
src/geo/src/GeoSolidArrayFactoryBase.cc:    dir_z = lpos_table->GetDArray("dir_z");
src/geo/src/GeoSolidArrayFactoryBase.cc:    orient_point_array = table->GetDArray("orient_point");
src/geo/src/GeoSolidArrayFactoryBase.cc:    new_radius = table->GetD("rescale_radius");
src/geo/src/GeoCutTubeFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoCutTubeFactory.cc:  G4double r_max = table->GetD("r_max") * CLHEP::mm;
src/geo/src/GeoCutTubeFactory.cc:  G4double size_z = table->GetD("size_z") * CLHEP::mm;
src/geo/src/GeoCutTubeFactory.cc:    r_min = table->GetD("r_min") * CLHEP::mm;
src/geo/src/GeoCutTubeFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoCutTubeFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoCutTubeFactory.cc:    std::vector<double> low_vector = table->GetDArray("low_norm");
src/geo/src/GeoCutTubeFactory.cc:    std::vector<double> high_vector = table->GetDArray("high_norm");
src/geo/src/GeoTubeArrayFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoTubeArrayFactory.cc:  G4double r_max = table->GetD("r_max") * CLHEP::mm;
src/geo/src/GeoTubeArrayFactory.cc:  G4double size_z = table->GetD("size_z") * CLHEP::mm;  // this is the lenght of the LG face to the PMT closest point
src/geo/src/GeoTubeArrayFactory.cc:    r_min = table->GetD("r_min") * CLHEP::mm;
src/geo/src/GeoTubeArrayFactory.cc:    phi_start = table->GetD("phi_start") * CLHEP::deg;
src/geo/src/GeoTubeArrayFactory.cc:    phi_delta = table->GetD("phi_delta") * CLHEP::deg;
src/geo/src/GeoTubeArrayFactory.cc:    s_cut_r = table->GetD("sphere_cut_r") * CLHEP::mm;
src/geo/src/GeoTubeArrayFactory.cc:    rescale_r = table->GetD("rescale_radius") * CLHEP::mm;
src/geo/src/GeoTubeArrayFactory.cc:    preflip = table->GetI("preflip");
src/geo/src/Materials.cc:    std::string namedb = i_table->first;
src/geo/src/Materials.cc:    DBLinkPtr table = i_table->second;
src/geo/src/Materials.cc:      csymbol = table->GetS("SYMBOL");
src/geo/src/Materials.cc:      zdb = table->GetI("z");
src/geo/src/Materials.cc:      const std::vector<int> &isotopes = table->GetIArray("isotopes");
src/geo/src/Materials.cc:      const std::vector<double> &isotopes_frac = table->GetDArray("isotopes_frac");
src/geo/src/Materials.cc:      adb = table->GetD("a");
src/geo/src/Materials.cc:    densitydb = table->GetD("density") * CLHEP::g / CLHEP::cm3;
src/geo/src/Materials.cc:    nelementsdb = table->GetI("nelements");
src/geo/src/Materials.cc:    nmaterialsdb = table->GetI("nmaterials");
src/geo/src/Materials.cc:    std::string stringstate = table->GetS("state");
src/geo/src/Materials.cc:    temperature = table->GetD("temperature");
src/geo/src/Materials.cc:    pressure = table->GetD("pressure") * CLHEP::STP_Pressure;
src/geo/src/Materials.cc:    formula = table->GetS("formula");
src/geo/src/Materials.cc:    mol = table->GetD("mol");
src/geo/src/Materials.cc:    std::vector<std::string> elemname = table->GetSArray("elements");
src/geo/src/Materials.cc:    std::vector<double> elemprop = table->GetDArray("elemprop");
src/geo/src/Materials.cc:    std::vector<std::string> elemname = table->GetSArray("materials");
src/geo/src/Materials.cc:    std::vector<double> elemprop = table->GetDArray("matprop");
src/geo/src/Materials.cc:        std::vector<G4Material *>::iterator it = tmp_table->begin() + tempptr->GetIndex();
src/geo/src/Materials.cc:        tmp_table->erase(it);
src/geo/src/Materials.cc:    std::string optstring = table->GetS(name + "_option");
src/geo/src/Materials.cc:    val1 = table->GetDArray(name + "_value1");
src/geo/src/Materials.cc:    val2 = table->GetDArray(name + "_value2");
src/geo/src/Materials.cc:    info << "Could not read property " << name << " of " << table->GetIndex() << newline;
src/geo/src/Materials.cc:    props = table->GetSArray("PROPERTY_LIST");
src/geo/src/Materials.cc:      mpt->AddConstProperty(i->c_str(), table->GetD(*i), true);
src/geo/src/Materials.cc:      props = table->GetSArray("PROPERTY_LIST");
src/geo/src/Materials.cc:      components = table->GetSArray("COMPONENTS");
src/geo/src/Materials.cc:      fractions = table->GetDArray("COMPONENT_FRACTIONS");
src/geo/src/GeoSolidFactory.cc:  detail << "GeoSolidFactory: Constructing volume " << table->GetIndex() << newline;
src/geo/src/GeoSolidFactory.cc:  std::string mother_name = table->GetS("mother");
src/geo/src/GeoSolidFactory.cc:      Log::Die("Unable to find mother volume \"" + mother_name + "\" for " + table->GetName() + "[" +
src/geo/src/GeoSolidFactory.cc:               table->GetIndex() + "]");
src/geo/src/GeoSolidFactory.cc:    replicas = table->GetI("replicas") > 1;
src/geo/src/GeoSolidFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/GeoSolidFactory.cc:  std::string material_name = table->GetS("material");
src/geo/src/GeoSolidFactory.cc:    std::string surface_name = table->GetS("surface");
src/geo/src/GeoSolidFactory.cc:    const std::vector<double> &color = table->GetDArray("color");
src/geo/src/GeoSolidFactory.cc:      warn << "GeoSolidFactory error: " << table->GetName() << "[" << table->GetIndex()
src/geo/src/GeoSolidFactory.cc:    int optimize = table->GetI("optimize");
src/geo/src/GeoSolidFactory.cc:      info << "GeoSolidFactory: Voxelization disabled for " << table->GetName() << "[" << table->GetIndex() << "]"
src/geo/src/GeoSolidFactory.cc:    std::string drawstyle = table->GetS("drawstyle");
src/geo/src/GeoSolidFactory.cc:      warn << "GeoSolidFactory error: " << table->GetName() << "[" << table->GetIndex()
src/geo/src/GeoSolidFactory.cc:    int force_auxedge = table->GetI("force_auxedge");
src/geo/src/GeoSolidFactory.cc:    int invisible = table->GetI("invisible");
src/geo/src/WLSPCoverFactory.cc:  std::string volume_name = table->GetIndex();
src/geo/src/WLSPCoverFactory.cc:  const std::vector<double> &outsize = table->GetDArray("outer_size");
src/geo/src/WLSPCoverFactory.cc:  const std::vector<double> &insize = table->GetDArray("inner_size");
src/cmd/src/ProcBlockManager.cc:  // ----------------Create processor allocator table-----------------
src/fit/src/FitTensorProc.cc:  std::string directory = table->GetS("directory");
build/CMakeFiles/CMakeOutput.log:Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.4.0-1ubuntu1~22.04' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-nvptx/usr,amdgcn-amdhsa=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2
build/CMakeFiles/CMakeOutput.log:Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.4.0-1ubuntu1~22.04' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-nvptx/usr,amdgcn-amdhsa=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2
build/CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.4.0-1ubuntu1~22.04' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c ada c++ go brig d fortran objc obj-c++ m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32 m64 mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-nvptx/usr amdgcn-amdhsa=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2]
build/CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.4.0-1ubuntu1~22.04' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c ada c++ go brig d fortran objc obj-c++ m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32 m64 mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-nvptx/usr amdgcn-amdhsa=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2]
build/CMakeFiles/CMakeOutput.log:Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.4.0-1ubuntu1~22.04' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-nvptx/usr,amdgcn-amdhsa=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2
build/CMakeFiles/CMakeOutput.log:Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.4.0-1ubuntu1~22.04' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-nvptx/usr,amdgcn-amdhsa=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2
build/CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.4.0-1ubuntu1~22.04' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c ada c++ go brig d fortran objc obj-c++ m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32 m64 mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-nvptx/usr amdgcn-amdhsa=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2]
build/CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.4.0-1ubuntu1~22.04' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c ada c++ go brig d fortran objc obj-c++ m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32 m64 mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-nvptx/usr amdgcn-amdhsa=/build/gcc-11-XeT9lY/gcc-11-11.4.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2]
